## Generated by RcppR6: do not edit by hand
## Version: 0.2.4
## Hash: e417a4c15fe850394d5cde6601f95e7f

##' @importFrom Rcpp evalCpp
##' @importFrom R6 R6Class
##' @useDynLib RcppQueues
NULL

##' Uniform distribution
##' @param min Lower bound of the distribution (default is zero)
##' @param max Upper bound of the distribution (default is one)
##' @export
`uniform` <- function(min=0.0, max=1.0) {
  uniform__ctor(min, max)
}
.R6_uniform <-
  R6::R6Class(
    "uniform",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      draw = function(n) {
        uniform__draw(self, n)
      },
      range = function() {
        uniform__range(self)
      }),
    active=list(
      min = function(value) {
        if (missing(value)) {
          uniform__min__get(self)
        } else {
          stop("uniform$min is read-only")
        }
      },
      max = function(value) {
        if (missing(value)) {
          uniform__max__get(self)
        } else {
          stop("uniform$max is read-only")
        }
      },
      the_min = function(value) {
        if (missing(value)) {
          uniform__the_min__get(self)
        } else {
          uniform__the_min__set(self, value)
        }
      },
      the_max = function(value) {
        if (missing(value)) {
          uniform__the_max__get(self)
        } else {
          uniform__the_max__set(self, value)
        }
      },
      u = function(value) {
        if (missing(value)) {
          uniform__u__get(self)
        } else {
          stop("uniform$u is read-only")
        }
      }))

##' @export
`stack` <- function() {
  stack__ctor()
}
.R6_stack <-
  R6::R6Class(
    "stack",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      pop = function() {
        stack__pop(self)
      },
      push = function(x) {
        stack__push(self, x)
      },
      equals = function(other) {
        stack__equals(self, other)
      },
      differs = function(other) {
        stack__differs(self, other)
      }),
    active=list(
      empty = function(value) {
        if (missing(value)) {
          stack__empty__get(self)
        } else {
          stop("stack$empty is read-only")
        }
      },
      size = function(value) {
        if (missing(value)) {
          stack__size__get(self)
        } else {
          stop("stack$size is read-only")
        }
      },
      top = function(value) {
        if (missing(value)) {
          stack__top__get(self)
        } else {
          stop("stack$top is read-only")
        }
      }))


`empty` <- function() {
  empty__ctor()
}
.R6_empty <-
  R6::R6Class(
    "empty",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      }),
    active=list())

##' A class for queueing human events. Header file defined [here](https://github.com/slwu89/RcppQueues/blob/master/inst/include/RcppQueues/HumanEventQ.hpp) and `RcppR6` export handled [here](https://github.com/slwu89/RcppQueues/blob/master/inst/HumanEventQ.yml).
##' @title Human Event Queue
##' @param initQ reserve memory for \code{initQ} number of events
##' @section Methods:
##'   * hi
##'     * nope.
##' @md
##' @export
`HumanEventQ` <- function(initQ=100) {
  HumanEventQ__ctor(initQ)
}
.R6_HumanEventQ <-
  R6::R6Class(
    "HumanEventQ",
    inherit=,
    portable=TRUE,
    public=list(
      .ptr=NULL,
      initialize = function(ptr) {
        self$.ptr <- ptr
      },
      firstEvent = function() {
        HumanEventQ__firstEvent(self)
      },
      rmFirstEventFromQ = function() {
        HumanEventQ__rmFirstEventFromQ(self)
      },
      rmTagFromQ = function(tag) {
        HumanEventQ__rmTagFromQ(self, tag)
      },
      get_queueN = function() {
        HumanEventQ__get_queueN(self)
      },
      addEvent2Q = function(event) {
        HumanEventQ__addEvent2Q(self, event)
      },
      get_eventQ = function() {
        HumanEventQ__get_eventQ(self)
      }),
    active=list())


